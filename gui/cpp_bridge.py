#!/usr/bin/env python3
"""
C++ Bridge for ToF Simulator GUI
Connects the Python GUI with the existing C++ data processing pipeline
"""

import subprocess
import os
import sys
import json
import time
from pathlib import Path
from typing import List, Dict, Optional, Tuple
import numpy as np
import struct

class CppBridge:
    """Bridge class to interact with C++ ToF simulator"""
    
    def __init__(self, cpp_executable_path: str = None):
        """
        Initialize the C++ bridge
        
        Args:
            cpp_executable_path: Path to the C++ ToFSimulator executable
        """
        if cpp_executable_path is None:
            # Try to find the executable automatically
            cpp_executable_path = self.find_cpp_executable()
        
        self.cpp_executable = cpp_executable_path
        self.working_dir = os.path.dirname(cpp_executable_path) if cpp_executable_path else "."
        
    def find_cpp_executable(self) -> Optional[str]:
        """Find the C++ ToFSimulator executable"""
        possible_paths = [
            "../build/Debug/ToFSimulator.exe",  # Windows
            "../build/ToFSimulator",           # Linux/Mac
            "build/Debug/ToFSimulator.exe",    # Relative to gui/
            "build/ToFSimulator",              # Relative to gui/
        ]
        
        for path in possible_paths:
            if os.path.exists(path):
                return os.path.abspath(path)
        
        return None
    
    def generate_synthetic_tof(self, width: int = 64, height: int = 64, 
                              num_frames: int = 4) -> bool:
        """
        Generate synthetic ToF data using the C++ pipeline
        
        Args:
            width: Image width
            height: Image height
            num_frames: Number of frames to generate
            
        Returns:
            True if successful, False otherwise
        """
        if not self.cpp_executable:
            print("Error: C++ executable not found")
            return False
        
        try:
            # Run the C++ executable to generate data
            result = subprocess.run(
                [self.cpp_executable],
                cwd=self.working_dir,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode == 0:
                print("Successfully generated synthetic ToF data")
                return True
            else:
                print(f"Error generating ToF data: {result.stderr}")
                return False
                
        except subprocess.TimeoutExpired:
            print("Timeout while generating ToF data")
            return False
        except Exception as e:
            print(f"Exception while generating ToF data: {e}")
            return False
    
    def get_generated_files(self) -> List[str]:
        """Get list of files generated by the C++ pipeline"""
        if not self.working_dir:
            return []
        
        generated_files = []
        
        # Look for common output files
        expected_files = [
            "tof_image.ppm",
            "fragment.ply"
        ]
        
        for filename in expected_files:
            filepath = os.path.join(self.working_dir, filename)
            if os.path.exists(filepath):
                generated_files.append(filepath)
        
        return generated_files
    
    def parse_ppm_header(self, filepath: str) -> Optional[Dict]:
        """Parse PPM file header to get image information"""
        try:
            with open(filepath, 'rb') as f:
                # Read magic number
                magic = f.readline().decode().strip()
                if magic != 'P6':
                    return None
                
                # Read dimensions
                dimensions = f.readline().decode().strip()
                width, height = map(int, dimensions.split())
                
                # Read max value
                max_val = int(f.readline().decode().strip())
                
                return {
                    'format': 'P6',
                    'width': width,
                    'height': height,
                    'max_value': max_val,
                    'filepath': filepath
                }
        except Exception as e:
            print(f"Error parsing PPM header: {e}")
            return None
    
    def parse_ply_info(self, filepath: str) -> Optional[Dict]:
        """Parse PLY file header to get point cloud information"""
        try:
            with open(filepath, 'rb') as f:
                # Read magic number
                line = f.readline().decode().strip()
                if line != 'ply':
                    return None
                
                info = {
                    'format': 'PLY',
                    'filepath': filepath,
                    'num_points': 0,
                    'num_faces': 0,
                    'has_color': False,
                    'format_type': 'unknown'
                }
                
                # Parse header
                while True:
                    line = f.readline().decode().strip()
                    if line == 'end_header':
                        break
                    
                    parts = line.split()
                    if len(parts) < 2:
                        continue
                    
                    if parts[0] == 'format':
                        info['format_type'] = parts[1]
                    elif parts[0] == 'element':
                        if parts[1] == 'vertex':
                            info['num_points'] = int(parts[2])
                        elif parts[1] == 'face':
                            info['num_faces'] = int(parts[2])
                    elif parts[0] == 'property':
                        if len(parts) >= 3 and parts[2] in ['red', 'green', 'blue']:
                            info['has_color'] = True
                
                return info
                
        except Exception as e:
            print(f"Error parsing PLY info: {e}")
            return None
    
    def get_data_summary(self) -> Dict:
        """Get a summary of all available data files"""
        summary = {
            'tof_images': [],
            'point_clouds': [],
            'cpp_executable': self.cpp_executable,
            'working_dir': self.working_dir
        }
        
        # Check for generated files
        generated_files = self.get_generated_files()
        
        for filepath in generated_files:
            if filepath.endswith('.ppm'):
                info = self.parse_ppm_header(filepath)
                if info:
                    summary['tof_images'].append(info)
            elif filepath.endswith('.ply'):
                info = self.parse_ply_info(filepath)
                if info:
                    summary['point_clouds'].append(info)
        
        return summary
    
    def run_cli_demo(self) -> str:
        """Run the C++ CLI demo and capture output"""
        if not self.cpp_executable:
            return "Error: C++ executable not found"
        
        try:
            result = subprocess.run(
                [self.cpp_executable],
                cwd=self.working_dir,
                capture_output=True,
                text=True,
                timeout=60
            )
            
            if result.returncode == 0:
                return result.stdout
            else:
                return f"Error: {result.stderr}"
                
        except subprocess.TimeoutExpired:
            return "Error: Timeout while running C++ demo"
        except Exception as e:
            return f"Error: {str(e)}"

class DataProcessor:
    """Process and convert data between C++ and Python formats"""
    
    @staticmethod
    def ppm_to_numpy(filepath: str) -> Optional[np.ndarray]:
        """Convert PPM file to numpy array"""
        try:
            with open(filepath, 'rb') as f:
                # Read header
                magic = f.readline().decode().strip()
                if magic != 'P6':
                    return None
                
                dimensions = f.readline().decode().strip()
                width, height = map(int, dimensions.split())
                
                max_val = int(f.readline().decode().strip())
                
                # Read image data
                data = f.read()
                img_array = np.frombuffer(data, dtype=np.uint8)
                img_array = img_array.reshape(height, width, 3)
                
                return img_array
                
        except Exception as e:
            print(f"Error converting PPM to numpy: {e}")
            return None
    
    @staticmethod
    def ply_to_numpy(filepath: str, max_points: int = 10000) -> Optional[np.ndarray]:
        """Convert PLY file to numpy array of points"""
        try:
            with open(filepath, 'rb') as f:
                # Read header
                line = f.readline().decode().strip()
                if line != 'ply':
                    return None
                
                num_points = 0
                format_type = 'unknown'
                
                # Parse header
                while True:
                    line = f.readline().decode().strip()
                    if line == 'end_header':
                        break
                    
                    parts = line.split()
                    if len(parts) >= 3 and parts[0] == 'element' and parts[1] == 'vertex':
                        num_points = int(parts[2])
                    elif len(parts) >= 2 and parts[0] == 'format':
                        format_type = parts[1]
                
                # Read points
                points = []
                points_to_read = min(num_points, max_points)
                
                if format_type == 'ascii':
                    for i in range(points_to_read):
                        line = f.readline().decode().strip()
                        x, y, z = map(float, line.split()[:3])
                        points.append([x, y, z])
                else:
                    # Binary format
                    for i in range(points_to_read):
                        data = f.read(12)  # 3 floats * 4 bytes
                        if len(data) == 12:
                            x, y, z = struct.unpack('fff', data)
                            points.append([x, y, z])
                
                return np.array(points)
                
        except Exception as e:
            print(f"Error converting PLY to numpy: {e}")
            return None

# Example usage
if __name__ == "__main__":
    bridge = CppBridge()
    
    print("C++ Bridge Test")
    print("=" * 30)
    
    # Check if C++ executable is available
    if bridge.cpp_executable:
        print(f"Found C++ executable: {bridge.cpp_executable}")
        
        # Get data summary
        summary = bridge.get_data_summary()
        print(f"Available ToF images: {len(summary['tof_images'])}")
        print(f"Available point clouds: {len(summary['point_clouds'])}")
        
        # Generate new data if needed
        if not summary['tof_images']:
            print("Generating synthetic ToF data...")
            bridge.generate_synthetic_tof()
        
    else:
        print("C++ executable not found")
        print("Make sure to build the C++ project first") 